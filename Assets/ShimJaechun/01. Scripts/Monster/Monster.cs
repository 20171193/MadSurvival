using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.UIElements;

namespace Jc
{
    public class Monster : MonoBehaviour, ITrackable
    {
        // 전체적인 게임 맵
        [SerializeField]
        private List<GroundList> gameMap;

        // 몬스터가 스폰된 타일
        public Ground onGround;

        private Ground playerGround;

        // 간략화
        private NavigationManager Navi => Manager.Navi;

        private void OnEnable()
        {
            // 플레이어의 타일 위치가 변경될 경우 발생할 액션
            Manager.Navi.OnChangePlayerGround += OnChangeTarget;
            // 게임맵 할당
            gameMap = Manager.Navi.gameMap;
        }
        private void OnDisable()
        {
            Manager.Navi.OnChangePlayerGround -= OnChangeTarget;
        }

        // 몬스터가 타일에 진입한 경우 세팅
        public void OnGround(Ground ground)
        {
            onGround = ground;
        }

        public void OnChangeTarget(Ground playerGround)
        {

        }

        // 목적지 세팅
        // 플레이어가 벽으로 둘러싸여 있는지 체크
        //  - true : 가장 가까운 벽으로 이동
        //  - false : 플레이어로 이동
        private Ground TargetSetting()
        {
            // 예외처리 : 플레이어가 타일 위에 위치하지않은 경우
            if (playerGround == null)
            {
                Debug.Log("플레이어가 위치한 타일이 존재하지 않습니다.");
                return null;
            }
            return null;
        }

        // 진지를 구축할 수 있는 좌표에서 탐색
        private Ground CheckPlayerBaseCamp()
        {
            int zPos = playerGround.Pos.z;
            int xPos = playerGround.Pos.x;

            // 플레이어가 진지를 구축할 수 없는 영역에 존재하는 경우
            // -> 목적지를 플레이어가 위치한 타일로 설정.
            if (zPos > Navi.cornerTL.z || zPos < Navi.cornerBL.z || xPos < Navi.cornerTL.x || xPos > Navi.cornerTR.x)
                return playerGround;

            // 플레이어가 진지를 구축할 수 있는 영역에 존재하는 경우
            // -> 체크 : 플레이어가 벽으로 둘러싸여있는지?

            // BFS 탐색
            Queue<GroundPos> q = new Queue<GroundPos>();
            // 방문확인 배열 생성 (원점 기준)
            bool[,] visitied = new bool[Navi.mapZsize/3,Navi.mapXsize/3];
            int resol = Navi.mapZsize / 3 - 1;
            // 4방향 탐색할 방향 설정
            int[] dz = { 0, 0, 1, -1 };
            int[] dx = { 1, -1, 0, 0 };
            q.Enqueue(playerGround.Pos);
            // 방문배열 확인을 위해 그라운드 위치를 원점좌표로 변환
            visitied[playerGround.Pos.z - resol, playerGround.Pos.x - resol] = true;

            while(q.Count > 0)
            {
                GroundPos curPos = q.Dequeue();
                for(int i =0; i<4; i++)
                {
                    int nz = dz[i] + curPos.z;
                    int nx = dx[i] + curPos.x;

                    // 예외처리 
                    if (nz > Navi.cornerTL.z || nz < Navi.cornerBL.z || nx < Navi.cornerTL.x || nx > Navi.cornerTR.x) continue;
                    if (visitied[nz - resol, nx - resol]) continue;
                    if (Navi.gameMap[nz].groundList[nx].type != GroundType.Buildable) continue;

                    // 벽이 뚫린 경우
                    if (nz >= Navi.cornerTL.z || nz <= Navi.cornerBL.z || nx <= Navi.cornerTL.x || nx >= Navi.cornerTR.x)
                        return playerGround;

                    q.Enqueue(new GroundPos(nz, nx));
                    visitied[nz-resol, nx-resol] = true;
                }
            }

            // 벽이 뚫리지 않은 경우 현재 위치에서 가장 가까운 벽을 목적지로 설정
            // 현재위치 -> 플레이어위치 레이캐스팅
            Vector3 startPos = new Vector3(onGround.transform.position.x, 0.2f, onGround.transform.position.z);
            Vector3 endPos = new Vector3(playerGround.transform.position.x, 0.2f, onGround.transform.position.z);
            Debug.DrawLine(startPos, endPos, Color.red, 0.5f);
            if (Physics.Raycast(new Ray(startPos, endPos), out RaycastHit hitInfo, (endPos - startPos).magnitude, Manager.Layer.wallLM))
            {
                if(hitInfo.transform.GetComponent<Ground>())
                {
                    
                }

                return hitInfo.transform.GetComponent<Ground>();
            }
            return null;
        }
    }
}